<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Production - Column layout (fixed add + alignment)</title>

<!-- SheetJS -->
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

<!-- Firebase (compat) CDN - app + firestore -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>

<style>
    :root {
        --blue: #1d4ed8;
        --blue-dark: #0f2b6c;
        --blue-light: #3b82f6;
        --accent: #0ea5e9;
        --slate: #4a5568;
        --slate-light: #64748b;
        --bg: #f0f4f8;
        --bg-light: #f8fafc;
        --card: #ffffff;
        --border: #cbd5e0;
        --border-light: #e2e8f0;
        --success: #10b981;
        --error: #ef4444;
    }
    * { box-sizing: border-box; margin:0; padding:0 }
    body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, var(--bg) 0%, var(--bg-light) 100%);
        color: var(--slate);
    }
    .page { max-width:1400px; margin:18px auto; padding:0 12px; }

    .hero {
        display:flex; align-items:center; justify-content:space-between;
        padding:16px; background: linear-gradient(135deg, var(--blue-dark), var(--blue));
        color:#fff; border-radius:10px; margin-bottom:12px;
    }
    .hero-title h1 { margin:0; font-size:1.2rem; font-weight:700 }
    .hero-title p { margin:6px 0 0; font-size:0.95rem; color:#e6f0ff }

    .panel { background:var(--card); border-radius:12px; padding:14px; border:1px solid var(--border-light); box-shadow:0 6px 20px rgba(0,0,0,0.04) }

    .controls { display:flex; gap:10px; align-items:center; margin-bottom:12px; flex-wrap:wrap; }
    .btn { background: linear-gradient(135deg, var(--blue), var(--blue-light)); color:#fff; padding:10px 14px; border-radius:10px; border:0; font-weight:700; cursor:pointer }
    .btn.ghost { background:#fff; color:var(--blue-dark); border:2px solid var(--border-light); box-shadow:none }
    .btn:disabled { background:#ccc; cursor:not-allowed; opacity:0.6; }

    /* Outlined transposed table */
    .transposed-wrap { border:1px solid var(--border-light); border-radius:10px; overflow:auto; background:#fff }
    .transposed { display:flex; gap:0; overflow:auto; align-items:flex-start; min-height:320px; }

    /* left label column */
    .fields-col{ min-width:320px; border-right:1px solid var(--border-light); background:linear-gradient(180deg,#fbfdff,#f7fbff); display:flex; flex-direction:column; }
    .columns-toolbar{ padding:12px 16px; border-bottom:1px solid var(--border-light); background:transparent; font-weight:800; color:var(--blue-dark) }
    .field-label { padding:10px 16px; border-bottom:1px solid var(--border-light); font-weight:700; color:var(--blue-dark); min-height:64px; display:flex; align-items:center }
    /* info icon beside certain field labels */
    .field-label .info-icon { display:inline-flex; align-items:center; justify-content:center; width:22px; height:22px; margin-left:8px; border-radius:50%; background:var(--blue-light); color:#fff; font-size:12px; cursor:default; position:relative }
    .field-label .info-icon:hover { background:var(--blue-dark); }
    .field-label .info-tooltip { display:none; position:absolute; top:28px; left:50%; transform:translateX(-50%); background:#111827; color:#fff; padding:8px 10px; border-radius:6px; font-size:12px; white-space:nowrap; max-width:580px; text-align:left; box-shadow:0 6px 28px rgba(0,0,0,0.16); z-index:6000 }
    .field-label .info-icon:hover .info-tooltip { display:block; }

    /* record columns */
    .record-col { min-width:260px; border-right:1px solid var(--border-light); background:#fff; display:flex; flex-direction:column; }
    .record-header { padding:12px 14px; border-bottom:1px solid var(--border-light); text-align:center; font-weight:700; color:var(--slate) }
    .record-col-inner { display:flex; flex-direction:column; }

    /* important: same height for label and input rows for perfect alignment */
    .cell { padding:8px 12px; border-bottom:1px solid var(--border-light); min-height:64px; display:flex; align-items:center; background:#fff }
    .cell input[type="text"], .cell input[type="number"], .cell input[type="date"], .cell input[type="time"] {
      width:100%; padding:10px 12px; border:2px solid var(--border); border-radius:8px; font-size:0.95rem; background:#fff; color:var(--slate);
      height:44px; box-sizing:border-box; max-width:260px;
    }
      .cell input.invalid { border-color: #ef4444 !important; box-shadow: 0 0 0 6px rgba(239,68,68,0.08); }
      .cell input.required-empty { border-color: #ef4444 !important; box-shadow: 0 0 0 6px rgba(239,68,68,0.08); background: #fff5f5 !important; }
    .cell input[type="text"]:focus, .cell input[type="number"]:focus, .cell input[type="date"]:focus { outline:none; border-color:var(--blue); box-shadow:0 0 0 6px rgba(59,130,246,0.06) }

    /* native time input: match other input styles */
    .time-visible, input[type="time"] { width:100%; padding:10px 12px; border:2px solid var(--border); border-radius:8px; height:44px; box-sizing:border-box; background:#fff; font-size:0.95rem; color:var(--slate); max-width:260px; }
    .time-visible:focus, input[type="time"]:focus { outline:none; border-color:var(--blue); box-shadow:0 0 0 6px rgba(59,130,246,0.06) }
    .time-visible.required-empty { border-color: #ef4444 !important; box-shadow: 0 0 0 6px rgba(239,68,68,0.08); background: #fff5f5 !important; }

    /* datetime-local input: 24-hour format */
    input[type="datetime-local"] { width:100%; padding:10px 12px; border:2px solid var(--border); border-radius:8px; height:44px; box-sizing:border-box; background:#fff; font-size:0.95rem; color:var(--slate); font-family: 'Segoe UI', monospace; max-width:260px; }
    input[type="datetime-local"]:focus { outline:none; border-color:var(--blue); box-shadow:0 0 0 6px rgba(59,130,246,0.06) }
    input[type="datetime-local"].invalid { border-color: #ef4444 !important; box-shadow: 0 0 0 6px rgba(239,68,68,0.08); }

    /* responsive: stack columns on small screens */
    @media (max-width:900px){
        .fields-col { min-width:240px }
        .record-col { min-width:240px }
    }
    @media (max-width:720px){
        .transposed { flex-direction:column }
        .fields-col, .record-col { width:100%; min-width:0 }
    }

    /* Mobile-specific: hide left labels column and show inline labels above inputs */
@media (max-width:720px){
    /* hide the left labels column */
    .fields-col { display: none; }

    /* stack each cell vertically and reduce min-height so it doesn't look empty */
    .cell {
        flex-direction: column;
        align-items: flex-start;
        min-height: auto;
        padding: 10px 12px;
        gap: 6px;
    }

    /* label shown above the input inside each cell — with info icon support */
    .cell .cell-label {
        display: flex;
        align-items: center;
        gap: 6px;
        font-weight: 700;
        color: var(--blue-dark);
        font-size: 0.95rem;
        line-height: 1.1;
        flex-wrap: wrap;
    }

    /* info icon on mobile */
    .cell .cell-label .info-icon { 
        display: inline-flex; 
        align-items: center; 
        justify-content: center; 
        width: 20px; 
        height: 20px; 
        border-radius: 50%; 
        background: var(--blue-light); 
        color: #fff; 
        font-size: 11px; 
        cursor: default; 
        position: relative;
        flex-shrink: 0;
        margin-left: 4px;
    }
    .cell .cell-label .info-icon:hover { background: var(--blue-dark); }
    .cell .cell-label .info-tooltip { 
        display: none; 
        position: absolute; 
        top: 26px; 
        left: 0; 
        transform: none; 
        max-width: 280px;
        background: #111827; 
        color: #fff; 
        padding: 8px 10px; 
        border-radius: 6px; 
        font-size: 11px; 
        white-space: normal; 
        text-align: left;
        box-shadow: 0 6px 18px rgba(0,0,0,0.16); 
        z-index: 2000;
    }
    .cell .cell-label .info-icon:hover .info-tooltip { display: block; }


    /* make header align left and a bit smaller on mobile */
    .record-header { text-align: left; font-size: 0.98rem; padding: 10px 12px; }

    /* make inputs full width (they already are, but ensure) */
    .cell input[type="text"], .cell input[type="number"], .cell input[type="date"], .cell input[type="time"], input[type="datetime-local"] {
        width: 100%;
    }
}

    /* Table styling for Show Entries: consistent widths and alignment */
    table { border-collapse:collapse; width:100%; }
    table th, table td { 
        border:1px solid var(--border-light); 
        padding:12px; 
        text-align:left; 
        word-wrap:break-word; 
        max-width:150px;
        overflow:hidden;
        text-overflow:ellipsis;
    }
    table th { 
        background:#f8fafc; 
        font-weight:700; 
        color:var(--slate); 
        position:sticky; 
        top:0; 
        z-index:10;
    }
    table td { background:#fff; color:var(--slate); font-size:0.9rem; }
    table tr:hover { background:#f8fafc; }
    table button { margin:0 4px; padding:6px 10px; font-size:0.85rem; }

</style>
</head>
<body>
<div class="page">
  <div class="hero">
    <div class="hero-title">
      <h1>Production Data</h1>
      <p>Fields on left. Each record is a vertical column of inputs.</p>
    </div>
    <div style="font-weight:700">Transposed / Column per record</div>
    <div style="display:flex;align-items:center;gap:8px;margin-left:12px">
      <div id="fbStatus" style="font-weight:600;color:rgba(255,255,255,0.95);font-size:0.9rem"></div>
    </div>
  </div>

  <div class="panel">
    <div class="controls">
      <button class="btn" id="addColBtn">+ Add Record</button>
      <!-- top-level Save removed (global Save sits below transposed area) -->
      <button class="btn ghost" id="loadBtn">Show Entries</button>

      <label class="btn ghost" style="display:inline-flex;align-items:center;gap:8px;cursor:pointer;">
        Import Excel
        <input id="importXlsx" type="file" accept=".xlsx,.xls" style="display:none" />
      </label>

      <button class="btn" id="exportBtn">Export Excel</button>

      <div style="margin-left:auto; color:var(--slate-light)">Tip: Click an input to edit. Time fields accept typing (<code>HH:MM</code> or <code>hh:mm AM/PM</code>) or native picker.</div>
    </div>

    <div class="transposed-wrap">
      <div class="transposed" id="transposedArea"></div>
    </div>

    <!-- Global per-panel action buttons (single pair) -->
    <div style="display:flex;justify-content:center;gap:12px;margin-top:10px;">
      <button id="saveBtn" class="btn">Save Field</button>
      <button id="clearAllFieldsBtn" class="btn ghost">Clear Fields</button>
    </div>
  </div>
</div>

<script>
/* HEADERS */
// All headers including Sr. No. (Sr. No. is stored in DB but not shown in the edit form)
const ALL_HEADERS = [
  "Sr. No.","Reactor No","Product Name","Category","Batch start date","Start time",
  "Heating start time","Total reflux time","Total fraction cut collection time",
  "Total feeding time","Total Main collection time","Heating stop time","Total heating hours",
  "Batch Stop Date","Batch stop time","Total Process Time","Total Input","Output",
  "Water","F-1","F-2","Residue","Drain qty while sampling",
  "Main Recovery%","Composite yield %","Cost","Remark"
];

/* header -> key */
const headerToKey = {};
// populate mapping for all headers
ALL_HEADERS.forEach(h => { const k = String(h).toLowerCase().replace(/\s+/g,'_').replace(/[^\w_]/g,''); headerToKey[h] = k; });

// headers used in the UI editor (don't show Sr. No.)
const HEADERS = ALL_HEADERS.filter(h => String(h).toLowerCase() !== 'sr. no.');

const STORAGE_KEY = "production_transposed_v1";
// when Firestore is unavailable and we save locally, keep a backup copy here
const LOCAL_SAVE_BACKUP_KEY = STORAGE_KEY + '_saved_backup';

// Fields that represent durations (not clock times)
const DURATION_FIELDS = [
  'total reflux time',
  'total fraction cut collection time',
  'total feeding time',
  'total main collection time'
];

// Fields that must be numeric only
const NUMERIC_ONLY_FIELDS = [
  'total input',
  'output',
  'water',
  'f-1',
  'f-2',
  'residue',
  'drain qty while sampling'
];

// Helpers for duration parsing/formatting: store as HH:MM (hours:minutes)
function parseDurationString(v){
  if(!v) return {h:'00', m:'00'};
  const s = String(v).trim();
  // legacy: "NN hours NN minutes"
  const m1 = s.match(/(\d{1,3})\s*hours?\s*(\d{1,2})\s*minutes?/i);
  if(m1) return { h: String(Number(m1[1])).padStart(2,'0'), m: String(Number(m1[2])).padStart(2,'0') };
  // HH:MM
  const m2 = s.match(/^(\d{1,3}):(\d{2})$/);
  if(m2) return { h: String(Number(m2[1])).padStart(2,'0'), m: String(Number(m2[2])).padStart(2,'0') };
  return {h:'00', m:'00'};
}
function formatDuration(h,m){
  const hh = String(h||'').padStart(2,'0');
  const mm = String(m||'').padStart(2,'0');
  return `${hh}:${mm}`;
}

// Helpers for datetime-local values (YYYY-MM-DDTHH:MM)
function toDateTimeLocalValue(v){
  if(!v) return '';
  // accept ISO-like strings or space-separated date+time
  let s = String(v).trim();
  // if already in YYYY-MM-DDTHH:MM format
  if(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}/.test(s)) return s.slice(0,16);
  // if ISO with space
  const isoSpace = s.match(/^(\d{4}-\d{2}-\d{2})[T\s](\d{2}:\d{2})/);
  if(isoSpace) return `${isoSpace[1]}T${isoSpace[2]}`;
  // if separate date and time
  const dateMatch = s.match(/(\d{4}-\d{2}-\d{2})/);
  const timeMatch = s.match(/(\d{1,2}:\d{2})/);
  if(dateMatch && timeMatch) return `${dateMatch[1]}T${timeMatch[1].padStart(5,'0')}`;
  return '';
}

/* default record */
function defaultRecord(){ const obj = {}; Object.values(headerToKey).forEach(k => obj[k]=""); return obj; }

/* load/save raw (no sanitizing) */
function loadRowsRaw(){
  const raw = localStorage.getItem(STORAGE_KEY);
  if(!raw) return [defaultRecord()];
  try { const arr = JSON.parse(raw); if(!Array.isArray(arr) || arr.length===0) return [defaultRecord()]; return arr; }
  catch(e){ console.warn(e); return [defaultRecord()]; }
}
function saveRows(rows){ localStorage.setItem(STORAGE_KEY, JSON.stringify(rows)); }

/* Clear/reset all inputs (persist a single blank/default record and re-render) */
function clearAllInputs(){
  saveRows([defaultRecord()]);
  renderTransposed();
  // also clear edit state and restore Save button text
  window.__EDIT_DOC_ID = null;
  const sb = document.getElementById('saveBtn'); if(sb) sb.textContent = 'Save Field';
}

// Clear fields across all columns but keep column blocks present
function clearAllFields(){
  const rows = loadRowsRaw();
  for(let i=0;i<rows.length;i++){
    if(rows[i] && rows[i].__simple) rows[i].quick_text = '';
    else if(rows[i]) Object.keys(rows[i]).forEach(k => { if(!String(k).startsWith('__')) rows[i][k] = ''; });
  }
  saveRows(rows); renderTransposed();
}

// full-clear: reset storage and app state back to an initial single blank record
function clearFields(){
  // remove saved rows and backups
  try{ localStorage.removeItem(STORAGE_KEY); localStorage.removeItem(LOCAL_SAVE_BACKUP_KEY); }catch(e){ console.warn('clearFields storage cleanup failed', e); }
  // reset in-memory markers
  window.__TRANS_DATA = null; window.__DB_LOADED_RECORDS = null; window.__EDIT_DOC_ID = null;
  // persist initial state and re-render
  saveRows([defaultRecord()]); renderTransposed();
  // clear any input validation markers
  document.querySelectorAll('.record-col input.invalid').forEach(i=>i.classList.remove('invalid'));
  toast('All fields and local data cleared');
}

// Validate all current rows: returns { ok: bool, invalid: [indices] }
function validateAllRows(){
  const rows = loadRowsRaw(); const invalid = [];
  const calculatedFieldKeys = [
    headerToKey['Total Process Time'],
    headerToKey['Total heating hours'],
    headerToKey['Cost'],
    headerToKey['Main Recovery%'],
    headerToKey['Composite yield %']
  ];
  
  rows.forEach((r, idx)=>{
    if(r && r.__simple){ if(!String(r.quick_text||'').trim()) invalid.push(idx); }
    else {
      // require at least one non-empty, non-special, non-calculated field
      const hasText = Object.keys(r||{}).some(k => 
        !String(k).startsWith('__') && 
        !calculatedFieldKeys.includes(k) &&
        r[k] !== undefined && 
        r[k] !== null && 
        String(r[k]).trim() !== ''
      );
      if(!hasText) invalid.push(idx);
    }
  });
  // Additional format validation for specific fields
  const time24SecondsRegex = /^(?:[01]\d|2[0-3]):[0-5]\d:[0-5]\d$/;
  const dateTimeRegex = /^\d{2}-\d{2}-\d{4}\s+(?:[01]\d|2[0-3]):[0-5]\d:[0-5]\d$/;
  const durationFormatRegex = /^\d{1,2}:\d{2}$/;
  
  rows.forEach((r, idx) => {
    if(!r || r.__simple) return;
    // start time must be 24-hour HH:MM:SS (max 23:59:59)
    if(r['start_time'] !== undefined && String(r['start_time']).trim() !== '' && !time24SecondsRegex.test(String(r['start_time']).trim())){
      if(!invalid.includes(idx)) invalid.push(idx);
    }
    // heating stop time must be dd-mm-yyyy hh:mm:ss
    if(r['heating_stop_time'] !== undefined && String(r['heating_stop_time']).trim() !== '' && !dateTimeRegex.test(String(r['heating_stop_time']).trim())){
      if(!invalid.includes(idx)) invalid.push(idx);
    }
    // duration fields: must be in HH:MM format if not empty
    DURATION_FIELDS.forEach(df => {
      const k = String(df).toLowerCase().replace(/\s+/g,'_').replace(/[^\w_]/g,'');
      if(r[k] !== undefined && String(r[k]).trim() !== ''){
        const val = String(r[k]).trim();
        // Must match HH:MM format exactly
        if(!durationFormatRegex.test(val)){
          if(!invalid.includes(idx)) invalid.push(idx);
        } else {
          // Validate ranges
          const match = val.match(/^(\d{1,2}):(\d{2})$/);
          if(match){
            const hh = Number(match[1]);
            const mm = Number(match[2]);
            if(mm < 0 || mm > 59 || hh < 0){
              if(!invalid.includes(idx)) invalid.push(idx);
            }
          }
        }
      }
    });

  });
  return { ok: invalid.length===0, invalid };
}

// mark invalid columns visually
function markInvalidColumns(indices){
  // clear previous
  document.querySelectorAll('.record-col input').forEach(i=>i.classList.remove('invalid'));
  const cols = document.querySelectorAll('.record-col');
  indices.forEach(i=>{
    const col = cols[i]; if(!col) return; const inputs = col.querySelectorAll('input'); inputs.forEach(inp=> inp.classList.add('invalid'));
  });
}

// clear a single column's inputs (keep remaining columns intact)
function clearColumnInputs(idx){
  const rows = loadRowsRaw(); if(!rows[idx]) return; Object.keys(rows[idx]).forEach(k => rows[idx][k] = ''); saveRows(rows); renderTransposed(); }

/* sanitize: remove fully-empty records (all fields blank) */
function sanitizeRecordsRaw(){
  const raw = (function(){
    // read raw stored rows without sanitization
    const s = localStorage.getItem(STORAGE_KEY);
    if(!s) return [];
    try{ const arr = JSON.parse(s); return Array.isArray(arr)?arr:[]; }catch(e){ return []; }
  })();

  const cleaned = [];
  const validKeys = Object.keys(defaultRecord());

  raw.forEach((rec, idx) => {
    if(!rec || typeof rec !== 'object') return;

    // If legacy simple record (compact), map quick_text into remark
    if(rec.__simple){
      const nr = defaultRecord();
      if(rec.quick_text) nr[ headerToKey['Remark'] || 'remark' ] = rec.quick_text;
      cleaned.push(nr);
      return;
    }

    // Build a normalized record containing only known keys
    const nr = defaultRecord();
    Object.keys(rec).forEach(k => {
      if(String(k).startsWith('__')) return; // skip internal markers
      if(validKeys.includes(k)) nr[k] = rec[k];
      // also accept legacy keys that may map to current keys (e.g., f1 vs f-1)
      else if(k === 'f1' && validKeys.includes('f_1')) nr['f_1'] = rec[k];
      else if(k === 'f2' && validKeys.includes('f_2')) nr['f_2'] = rec[k];
      else if(k === 'packing_size' && validKeys.includes('packing_size')) nr['packing_size'] = rec[k];
      else if(k === 'total_drum_packed' && validKeys.includes('total_drum_packed')) nr['total_drum_packed'] = rec[k];
      else if(k === 'packing_moc' && validKeys.includes('packing_moc')) nr['packing_moc'] = rec[k];
    });

    // If record contains any non-empty value, keep it
    const hasAny = Object.values(nr).some(v => v !== '' && v !== null && v !== undefined && String(v).trim() !== '');
    if(hasAny) cleaned.push(nr);
  });

  if(cleaned.length === 0) return [defaultRecord()];
  return cleaned;
}

/* loadData returns sanitized data and persists cleaned version */
function loadData(){
  const cleaned = sanitizeRecordsRaw();
  saveRows(cleaned);
  return cleaned;
}

/* DEBUG: Log all field mappings */
function logFieldMappings(){
  console.log('===== FIELD MAPPING DIAGNOSTICS =====');
  console.log('ALL_HEADERS count:', ALL_HEADERS.length);
  console.log('ALL_HEADERS:', ALL_HEADERS);
  console.log('\nheaderToKey mappings:');
  ALL_HEADERS.forEach(h => {
    console.log(`  "${h}" -> "${headerToKey[h]}"`);
  });
  console.log('\nNUMERIC_ONLY_FIELDS:', NUMERIC_ONLY_FIELDS);
  console.log('DURATION_FIELDS:', DURATION_FIELDS);
  console.log('\nSample defaultRecord:', defaultRecord());
  console.log('defaultRecord keys count:', Object.keys(defaultRecord()).length);
}

/* Validate all fields in a single record are filled */
function validateRecordAllFieldsFilled(rec, colIndex){
  const inputs = document.querySelectorAll(`.record-col:nth-child(${colIndex + 2}) .cell input, .record-col:nth-child(${colIndex + 2}) .cell .time-visible, .record-col:nth-child(${colIndex + 2}) .cell .calculated-display`);
  let allFilled = true;
  
  inputs.forEach(input => {
    const val = String(input.value || '').trim();
    // Skip calculated fields (they auto-populate)
    if(input.classList.contains('calculated-display') || input.disabled) return;
    
    if(!val){
      input.classList.add('required-empty');
      allFilled = false;
    } else {
      input.classList.remove('required-empty');
    }
  });
  
  return allFilled;
}

/* Validate all records have all fields filled */
function validateAllRecordsComplete(){
  const data = loadData();
  let allValid = true;
  
  data.forEach((rec, idx) => {
    const isValid = validateRecordAllFieldsFilled(rec, idx);
    if(!isValid) allValid = false;
  });
  
  return allValid;
}

/* Clear required-empty indicators */
function clearValidationIndicators(){
  document.querySelectorAll('.required-empty').forEach(el => {
    el.classList.remove('required-empty');
  });
}

// ----------------------
// Firebase initialization (compat SDK)
// ----------------------
const firebaseConfig = {
  apiKey: "AIzaSyDBHgDWViT-YqyGgkcTX9nS6Ewe2Y7M23s",
  authDomain: "ccpl-production.firebaseapp.com",
  projectId: "ccpl-production",
  storageBucket: "ccpl-production.firebasestorage.app",
  messagingSenderId: "192591041978",
  appId: "1:192591041978:web:f3faf7522279e75d4ff983",
  measurementId: "G-55D64M975T"
};

try{
  if (typeof firebase !== 'undefined' && firebase && !firebase.apps?.length){
    firebase.initializeApp(firebaseConfig);
  }
}catch(e){ console.warn('Firebase init warning', e); }

const db = (typeof firebase !== 'undefined' && firebase && firebase.firestore) ? firebase.firestore() : null;

// Firestore rules that you should set in the Firebase Console (Security Rules)
const FIRESTORE_RULES = `rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    match /metadata/{document=**} {
      allow read, write: if request.auth != null;
    }

    match /tableData/{document=**} {
      allow read, write: if request.auth != null;
    }

    match /{document=**} {
      allow read, write: if request.auth != null;
    }
  }
}`;

// Ensure authentication (anonymous) for Firestore operations
async function ensureAuth(){
  if(!(typeof firebase !== 'undefined' && firebase && firebase.auth)){
    console.warn('Firebase auth not available');
    return false;
  }
  if(firebase.auth().currentUser){ window.__FIREBASE_USER = firebase.auth().currentUser; return true; }
  try{
    const creds = await firebase.auth().signInAnonymously();
    window.__FIREBASE_USER = creds.user;
    console.log('Signed in anonymously:', creds.user && creds.user.uid);
    toast('Signed in to Firebase (anonymous)');
    const el = document.getElementById('fbStatus'); if(el) el.textContent = 'DB: signed in (anonymous)';
    return true;
  }catch(err){ console.error('anonymous sign-in failed', err); toast('Firebase sign-in failed (see console)'); const el = document.getElementById('fbStatus'); if(el) el.textContent = 'DB: auth failed'; return false; }
}

// try to sign in immediately (best-effort)
ensureAuth().catch(()=>{}).then(()=>{
  const el = document.getElementById('fbStatus'); if(el && (!window.__FIREBASE_USER)) el.textContent = 'DB: not signed-in';
});

// UI: rules toggle and copy functionality
document.addEventListener('click', (e)=>{
  if(e.target && e.target.id === 'showRulesBtn'){
    let existing = document.getElementById('rulesPanel');
    if(existing){ existing.remove(); return; }
    const el = document.createElement('div'); el.id='rulesPanel';
    el.style.position='absolute'; el.style.top='86px'; el.style.right='18px'; el.style.maxWidth='540px'; el.style.zIndex=2000;
    el.style.background='white'; el.style.color='#0f172a'; el.style.border='1px solid var(--border-light)'; el.style.borderRadius='10px';
    el.style.boxShadow='0 10px 30px rgba(2,6,23,0.12)'; el.style.padding='12px';
    const title = document.createElement('div'); title.textContent='Recommended Firestore Security Rules'; title.style.fontWeight='800'; title.style.marginBottom='8px'; el.appendChild(title);
    const pre = document.createElement('pre'); pre.textContent = FIRESTORE_RULES; pre.style.whiteSpace='pre-wrap'; pre.style.background='#fafafa'; pre.style.padding='8px'; pre.style.borderRadius='8px'; pre.style.border='1px solid var(--border-light)'; pre.style.maxHeight='260px'; pre.style.overflow='auto'; el.appendChild(pre);
    const copyBtn = document.createElement('button'); copyBtn.textContent='Copy rules to clipboard'; copyBtn.style.marginTop='8px'; copyBtn.style.padding='8px 10px'; copyBtn.style.border='0'; copyBtn.style.borderRadius='8px'; copyBtn.style.background='linear-gradient(135deg,var(--blue),var(--blue-light))'; copyBtn.style.color='white'; copyBtn.style.fontWeight='700'; copyBtn.style.cursor='pointer';
    copyBtn.onclick = async ()=>{ try{ await navigator.clipboard.writeText(FIRESTORE_RULES); toast('Copied rules to clipboard'); }catch(err){ console.error(err); toast('Copy failed (see console)'); } };
    el.appendChild(copyBtn);
    document.body.appendChild(el);
  }
});

// Helper: save an array of records into Firestore, auto-assigning sr_no using a counter document
async function saveToFirestore(records){
  console.log('===== START saveToFirestore =====');
  console.log('Input records count:', records ? records.length : 0);
  console.log('Input records:', records);
  
  if(!db) throw new Error('Firestore not initialized');
  const ok = await ensureAuth();
  if(!ok) throw new Error('Not authenticated for Firestore operations');
  const counterRef = db.collection('metadata').doc('counters');
  const prodRef = db.collection('production_records');
  
  // Filter out records that are completely empty (all fields blank or null)
  // Note: Don't filter based on ALL values being empty - save records even if they have sparse data
  const toSave = (records || []).filter(rec => {
    if(!rec) {
      console.log('Filtering out: record is null/undefined');
      return false;
    }
    // Check if record has any non-empty, non-internal field
    const hasData = Object.entries(rec).some(([k, v]) => 
      !String(k).startsWith('__') && 
      v !== "" && 
      v !== null && 
      v !== undefined
    );
    if(!hasData) console.log('Filtering out: record has no non-empty fields', rec);
    return hasData;
  });
  
  console.log('Records to save after filtering:', toSave.length);
  console.log('Filtered records:', toSave);
  
  if(toSave.length === 0) { 
    console.warn('No non-empty records to save'); 
    console.log('===== END saveToFirestore (no records) =====');
    return { saved: 0 }; 
  }

  try{
    await db.runTransaction(async tx => {
      const cdoc = await tx.get(counterRef);
      let last = 0;
      if(cdoc.exists) last = cdoc.data().lastSerial || 0;
      const nextStart = last + 1;
      const nextEnd = last + toSave.length;
      if(cdoc.exists) tx.update(counterRef, { lastSerial: nextEnd }); else tx.set(counterRef, { lastSerial: nextEnd });

      for(let i=0;i<toSave.length;i++){
        const rec = toSave[i];
        const payload = Object.assign({}, rec);
        payload.sr_no = nextStart + i;
        payload.createdAt = firebase.firestore.FieldValue.serverTimestamp ? firebase.firestore.FieldValue.serverTimestamp() : new Date().toISOString();
        const newDoc = prodRef.doc();
        tx.set(newDoc, payload);
        console.log('Saving record ' + (i+1) + ' with sr_no: ' + payload.sr_no);
      }
    });
    console.log('Successfully saved ' + toSave.length + ' records to Firestore');
    return { saved: toSave.length };
  }catch(err){
    console.error('saveToFirestore error', err);
    console.error('Error code:', err.code);
    console.error('Error message:', err.message);
    throw err;
  }
}

// update a single Firestore document by id with a record's fields
async function updateFirestoreDoc(id, record){
  if(!db) throw new Error('Firestore not initialized');
  if(!id) throw new Error('Missing document id');
  const ok = await ensureAuth(); if(!ok) throw new Error('Not authenticated');
  const ref = db.collection('production_records').doc(id);
  const payload = Object.assign({}, record);
  // add updatedAt timestamp
  payload.updatedAt = firebase.firestore.FieldValue.serverTimestamp ? firebase.firestore.FieldValue.serverTimestamp() : new Date().toISOString();
  await ref.update(payload);
  return { id, updated: true };
}

// delete a firestore document by id
async function deleteFirestoreDoc(id){
  if(!db) throw new Error('Firestore not initialized');
  if(!id) throw new Error('Missing document id');
  const ok = await ensureAuth(); if(!ok) throw new Error('Not authenticated');
  const ref = db.collection('production_records').doc(id);
  await ref.delete();
  return { id, deleted: true };
}

// Fill the editor (top transposed UI) with a record and mark it as being edited (store doc id)
function fillEditorWithRecord(rec, docId){
  // build a data object matching UI HEADERS keys
  const obj = defaultRecord();
  HEADERS.forEach(h => {
    const k = headerToKey[h];
    if(k && rec[k] !== undefined) obj[k] = rec[k];
  });
  // persist one record to local storage and mark edit ID
  saveRows([obj]);
  window.__EDIT_DOC_ID = docId; // used by save handler
  renderTransposed();
  const sb = document.getElementById('saveBtn'); if(sb) sb.textContent = 'Update Record';
  toast('Loaded record into editor — edit and click Save');
}

// Helper: load all records from Firestore ordered by sr_no
async function loadFromFirestore(){
  if(!db) throw new Error('Firestore not initialized');
  const ok = await ensureAuth();
  if(!ok) throw new Error('Not authenticated for Firestore operations');
  const prodRef = db.collection('production_records');
  const snapshot = await prodRef.orderBy('sr_no','asc').get();
  const rows = snapshot.docs.map(d => ({ id: d.id, ...d.data() }));
  // store last fetched DB rows for export/use
  window.__DB_LOADED_RECORDS = rows;
  renderTable(rows);
  toast('Loaded ' + rows.length + ' rows from database');
  return rows;
}

// Render a regular table (rows) inside the transposed area for DB data (Excel-like)
function renderTable(records){
  const area = document.getElementById('transposedArea');
  area.innerHTML = '';
  const wrap = document.createElement('div'); wrap.style.padding = '12px';
  const table = document.createElement('table'); table.style.width='100%'; table.style.borderCollapse='collapse';
  table.style.fontSize='0.9rem';
  const thead = document.createElement('thead');
  const trh = document.createElement('tr');
  // export headers: Sr. No. + HEADERS (UI fields) + Actions
  const headerRow = ['Sr. No.', ...HEADERS, 'Actions'];
  headerRow.forEach(h => {
    const th = document.createElement('th'); th.textContent = h; th.style.padding='8px'; th.style.border='1px solid var(--border-light)'; th.style.background='#f8fafc'; th.style.textAlign='left'; trh.appendChild(th);
  });
  thead.appendChild(trh);
  table.appendChild(thead);

  const tbody = document.createElement('tbody');
  records.forEach((rec, idx) => {
    const tr = document.createElement('tr');
    // compute Sr. No. as contiguous index (re-number for display)
    const sr = idx + 1;
    const cells = [sr, ...HEADERS.map(h => { const key = headerToKey[h] || (String(h).toLowerCase().replace(/\s+/g,'_').replace(/[^\w_]/g,'')); return rec[key] !== undefined ? rec[key] : ''; })];
    cells.forEach(c => { const td = document.createElement('td'); td.textContent = c; td.style.padding='8px'; td.style.border='1px solid var(--border-light)'; tr.appendChild(td); });

    // actions cell: Edit & Delete
    const actionsTd = document.createElement('td'); actionsTd.style.padding='8px'; actionsTd.style.border='1px solid var(--border-light)'; actionsTd.style.textAlign = 'center';
    const editBtn = document.createElement('button'); editBtn.textContent = 'Edit'; editBtn.className='btn ghost'; editBtn.style.marginRight='6px';
    editBtn.onclick = () => { try{ fillEditorWithRecord(rec, rec.id); }catch(e){ console.error('fill edit failed', e); toast('Failed to prepare edit'); } };
    const deleteBtn = document.createElement('button'); deleteBtn.textContent = 'Delete'; deleteBtn.className='btn'; deleteBtn.onclick = async ()=>{
      if(!confirm('Are you sure you want to delete this record?')) return;
      try{ await deleteFirestoreDoc(rec.id); toast('Record deleted'); await loadFromFirestore(); }catch(err){ console.error(err); alert('Delete failed (see console)'); }
    };
    actionsTd.appendChild(editBtn); actionsTd.appendChild(deleteBtn);
    tr.appendChild(actionsTd);
    tbody.appendChild(tr);
  });
  table.appendChild(tbody);
  wrap.appendChild(table);
  area.appendChild(wrap);
  // mark last render mode
  window.__LAST_RENDER_MODE = 'table';
}

/* helpers for time */
function pad(n){ return n<10 ? '0'+n : String(n); }
// Parse time string to strict 24-hour format HH:MM (no AM/PM)
function parseTime24(v){
  if(!v) return "";
  v = String(v).trim();
  // Already in 24-hour format
  if(/^(?:[01]\d|2[0-3]):[0-5]\d$/.test(v)) return v;
  // Try to extract HH:MM from any format
  const match = v.match(/(\d{1,2}):(\d{2})/);
  if(match){
    const h = parseInt(match[1], 10);
    const m = parseInt(match[2], 10);
    if(h >= 0 && h < 24 && m >= 0 && m < 60) return pad(h) + ':' + pad(m);
  }
  return "";
}

// Compute Total heating hours = Heating stop time - Heating start time
// Returns difference in HH:MM format
function computeTotalHeatingHours(rec){
  if(!rec) return '';
  const heatingStartKey = headerToKey['Heating start time'];
  const heatingStopKey = headerToKey['Heating stop time'];
  const totalHeatingHoursKey = headerToKey['Total heating hours'];
  
  if(!heatingStartKey || !heatingStopKey || !totalHeatingHoursKey) return '';
  
  const startStr = String(rec[heatingStartKey] || '').trim();
  const stopStr = String(rec[heatingStopKey] || '').trim();
  
  if(!startStr || !stopStr) { rec[totalHeatingHoursKey] = ''; return ''; }
  
  // Flexible parsing: support
  // - dd-mm-yyyy HH:MM:SS (or HH:MM)
  // - YYYY-MM-DDTHH:MM(:SS)
  // - HH:MM(:SS) (time-only)
  function parseFlexible(dtStr){
    if(!dtStr) return null;
    const s = String(dtStr).trim();
    // dd-mm-yyyy HH:MM:SS or dd-mm-yyyy HH:MM
    let m = s.match(/^(\d{1,2})-(\d{1,2})-(\d{4})(?:\s+(\d{1,2}):(\d{2})(?::(\d{2}))?)?$/);
    if(m){
      const dd = Number(m[1]); const mm = Number(m[2]); const yyyy = Number(m[3]);
      const hh = Number(m[4]||0); const min = Number(m[5]||0); const ss = Number(m[6]||0);
      return new Date(yyyy, mm-1, dd, hh, min, ss);
    }
    // ISO-like YYYY-MM-DDTHH:MM(:SS) or space separated
    m = s.match(/^(\d{4})-(\d{2})-(\d{2})[T\s](\d{1,2}):(\d{2})(?::(\d{2}))?/);
    if(m){
      const yyyy = Number(m[1]); const mm = Number(m[2]); const dd = Number(m[3]);
      const hh = Number(m[4]||0); const min = Number(m[5]||0); const ss = Number(m[6]||0);
      return new Date(yyyy, mm-1, dd, hh, min, ss);
    }
    // Time-only HH:MM(:SS)
    m = s.match(/^(\d{1,2}):(\d{2})(?::(\d{2}))?$/);
    if(m){
      const hh = Number(m[1]); const min = Number(m[2]); const ss = Number(m[3]||0);
      // Use today's date as base for time-only values
      const now = new Date();
      return new Date(now.getFullYear(), now.getMonth(), now.getDate(), hh, min, ss);
    }
    return null;
  }

  const hasDateRegex = /(\d{1,2}-\d{1,2}-\d{4})|(\d{4}-\d{2}-\d{2})/;
  const startHasDate = hasDateRegex.test(startStr);
  const stopHasDate = hasDateRegex.test(stopStr);

  // Parse into Date objects
  let startDt = parseFlexible(startStr);
  let stopDt = parseFlexible(stopStr);
  if(!startDt || !stopDt){ rec[totalHeatingHoursKey] = ''; return ''; }

  // If one side had only time and the other had a date, align the time-only to the date-containing side
  if(startHasDate && !stopHasDate){
    // take time from stopDt and date from startDt
    stopDt = new Date(startDt.getFullYear(), startDt.getMonth(), startDt.getDate(), stopDt.getHours(), stopDt.getMinutes(), stopDt.getSeconds());
    if(stopDt < startDt) stopDt.setDate(stopDt.getDate() + 1);
  } else if(!startHasDate && stopHasDate){
    startDt = new Date(stopDt.getFullYear(), stopDt.getMonth(), stopDt.getDate(), startDt.getHours(), startDt.getMinutes(), startDt.getSeconds());
    // if start is after stop, assume start was previous day
    if(startDt > stopDt) startDt.setDate(startDt.getDate() - 1);
  } else if(!startHasDate && !stopHasDate){
    // both time-only: if stop earlier than start, assume next day
    if(stopDt < startDt) stopDt.setDate(stopDt.getDate() + 1);
  }

  // If both had explicit dates and stop is before start, treat as invalid
  if(startHasDate && stopHasDate && stopDt < startDt){ rec[totalHeatingHoursKey] = ''; return ''; }

  const diffMs = stopDt.getTime() - startDt.getTime();
  if(isNaN(diffMs) || diffMs < 0){ rec[totalHeatingHoursKey] = ''; return ''; }
  const diffMins = Math.round(diffMs / 60000);
  const hh = Math.floor(diffMins / 60);
  const mm = diffMins % 60;
  const out = String(hh).padStart(2,'0') + ':' + String(mm).padStart(2,'0');
  rec[totalHeatingHoursKey] = out;
  return out;
}

// Compute Total Process Time = Batch Stop Date/Time - Batch Start Date/Time
// Uses date + time combination to handle multi-day processes
function computeTotalProcessTimeForRecord(rec){
  if(!rec) return '';
  const batchStartDateKey = headerToKey['Batch start date'];
  const batchStartTimeKey = headerToKey['Start time'];
  const batchStopDateKey = headerToKey['Batch Stop Date'];
  const batchStopTimeKey = headerToKey['Batch stop time'];
  const totalProcessTimeKey = headerToKey['Total Process Time'];
  
  if(!batchStartDateKey || !batchStartTimeKey || !batchStopDateKey || !batchStopTimeKey || !totalProcessTimeKey) return '';
  
  const startDateStr = String(rec[batchStartDateKey] || '').trim();
  const startTimeStr = String(rec[batchStartTimeKey] || '').trim();
  const stopDateStr = String(rec[batchStopDateKey] || '').trim();
  const stopTimeStr = String(rec[batchStopTimeKey] || '').trim();
  
  if(!startDateStr || !startTimeStr || !stopDateStr || !stopTimeStr) { rec[totalProcessTimeKey] = ''; return ''; }
  
  // Combine date + time strings into unified datetime
  const startDtStr = startDateStr + ' ' + startTimeStr;
  const stopDtStr = stopDateStr + ' ' + stopTimeStr;
  
  // Flexible parsing for combined datetime strings
  function parseFlexibleDt(dtStr){
    if(!dtStr) return null;
    const s = String(dtStr).trim();
    // dd-mm-yyyy hh:mm:ss or dd-mm-yyyy HH:MM:SS or YYYY-MM-DD HH:MM:SS
    let m = s.match(/^(\d{1,2})-(\d{1,2})-(\d{4})\s+(\d{1,2}):(\d{2})(?::(\d{2}))?$/);
    if(m){
      const dd = Number(m[1]); const mm = Number(m[2]); const yyyy = Number(m[3]);
      const hh = Number(m[4]||0); const min = Number(m[5]||0); const ss = Number(m[6]||0);
      return new Date(yyyy, mm-1, dd, hh, min, ss);
    }
    // ISO-like YYYY-MM-DD HH:MM(:SS)
    m = s.match(/^(\d{4})-(\d{2})-(\d{2})\s+(\d{1,2}):(\d{2})(?::(\d{2}))?/);
    if(m){
      const yyyy = Number(m[1]); const mm = Number(m[2]); const dd = Number(m[3]);
      const hh = Number(m[4]||0); const min = Number(m[5]||0); const ss = Number(m[6]||0);
      return new Date(yyyy, mm-1, dd, hh, min, ss);
    }
    return null;
  }
  
  let startDt = parseFlexibleDt(startDtStr);
  let stopDt = parseFlexibleDt(stopDtStr);
  
  if(!startDt || !stopDt){ rec[totalProcessTimeKey] = ''; return ''; }
  
  // If stop is before start, treat as invalid
  if(stopDt < startDt){ rec[totalProcessTimeKey] = ''; return ''; }
  
  const diffMs = stopDt.getTime() - startDt.getTime();
  if(isNaN(diffMs) || diffMs < 0){ rec[totalProcessTimeKey] = ''; return ''; }
  
  const diffMins = Math.round(diffMs / 60000);
  const hh = Math.floor(diffMins / 60);
  const mm = diffMins % 60;
  const out = String(hh).padStart(2,'0') + ':' + String(mm).padStart(2,'0');
  
  rec[totalProcessTimeKey] = out;
  return out;
}

// Old: Compute Total Process Time for a record by summing duration fields (HH:MM)
// Returns empty string if no duration fields are filled
// function computeTotalProcessTimeForRecordOld(rec){

// Compute Main Recovery % = (Output / Total Input) * 100
function computeMainRecoveryPercent(rec){
  if(!rec) return '';
  const totalInputKey = headerToKey['Total Input'];
  const outputKey = headerToKey['Output'];
  const mainRecoveryKey = headerToKey['Main Recovery%'];
  if(!totalInputKey || !outputKey || !mainRecoveryKey) return '';
  
  const ti = String(rec[totalInputKey] || '').trim();
  const out = String(rec[outputKey] || '').trim();
  if(!ti || !out) { rec[mainRecoveryKey] = ''; return ''; }
  
  const tiNum = parseFloat(ti);
  const outNum = parseFloat(out);
  if(isNaN(tiNum) || isNaN(outNum) || tiNum === 0) { rec[mainRecoveryKey] = ''; return ''; }
  
  const result = (outNum / tiNum * 100).toFixed(2);
  rec[mainRecoveryKey] = result;
  return result;
}

// Compute Composite Yield % = (Output + Water + F-1 + F-2 + Drain qty while sampling + Residue) / Total Input * 100
function computeCompositeYield(rec){
  if(!rec) return '';
  const numeratorFields = ['Output', 'Water', 'F-1', 'F-2', 'Drain qty while sampling', 'Residue'];
  const compositeKey = headerToKey['Composite yield %'];
  const totalInputKey = headerToKey['Total Input'];
  if(!compositeKey || !totalInputKey) return '';

  // Sum numerator fields
  let sum = 0;
  for(const fieldName of numeratorFields){
    const key = headerToKey[fieldName];
    if(!key) continue;
    const val = String(rec[key] || '').trim();
    if(!val) continue;
    const num = parseFloat(val);
    if(!isNaN(num)) sum += num;
  }

  // Read and validate total input
  const totalInputStr = String(rec[totalInputKey] || '').trim();
  const totalInput = parseFloat(totalInputStr);
  if(!totalInputStr || isNaN(totalInput) || totalInput === 0){
    rec[compositeKey] = '';
    return '';
  }

  const percent = (sum / totalInput) * 100;
  const result = percent.toFixed(2);
  rec[compositeKey] = result;
  return result;
}

// Compute Cost = Total Process Time (hours) * 4000 / Total Input
// Total Process Time is in HH:MM format; convert minutes to fractional hours (mm/60)
// Returns empty string if Total Process Time or Total Input is missing/invalid
function computeCost(rec){
  if(!rec) return '';
  const totalHeatingHoursKey = headerToKey['Total heating hours'];
  const costKey = headerToKey['Cost'];
  const totalInputKey = headerToKey['Total Input'];
  if(!totalHeatingHoursKey || !costKey || !totalInputKey) return '';

  const timeStr = String(rec[totalHeatingHoursKey] || '').trim();
  // If Total heating hours is empty, clear cost
  if(!timeStr) { rec[costKey] = ''; return ''; }

  // Parse HH:MM format (allow more than 2 digits for hours)
  const match = timeStr.match(/^(\d+):(\d{2})$/);
  if(!match) { rec[costKey] = ''; return ''; }

  const hh = Number(match[1]);
  const mm = Number(match[2]);
  if(isNaN(hh) || isNaN(mm) || mm < 0 || mm >= 60){ rec[costKey] = ''; return ''; }

  // Convert HH:MM to decimal hours
  const hours = hh + (mm / 60);

  // Read Total Input and validate
  const totalInputStr = String(rec[totalInputKey] || '').trim();
  const totalInput = parseFloat(totalInputStr);
  if(!totalInputStr || isNaN(totalInput) || totalInput === 0){ rec[costKey] = ''; return ''; }

  // Calculate cost: total heating hours * (4000 / totalInput)
  const cost = (hours * (4000 / totalInput)).toFixed(2);
  rec[costKey] = cost;
  return cost;
}

function computeTotalsForAllRecords(){
  const rows = loadRowsRaw(); let changed = false;
  for(let i=0;i<rows.length;i++){
    const rec = rows[i];
    if(!rec) continue;
    
    // Total Process Time
    const beforeTime = String(rec[ headerToKey['Total Process Time'] ] || '');
    const afterTime = computeTotalProcessTimeForRecord(rec);
    if(beforeTime !== afterTime) changed = true;
    
    // Total Heating Hours
    const beforeHeatingHours = String(rec[ headerToKey['Total heating hours'] ] || '');
    const afterHeatingHours = computeTotalHeatingHours(rec);
    if(beforeHeatingHours !== afterHeatingHours) changed = true;
    
    // Main Recovery %
    const beforeMainRecovery = String(rec[ headerToKey['Main Recovery%'] ] || '');
    const afterMainRecovery = computeMainRecoveryPercent(rec);
    if(beforeMainRecovery !== afterMainRecovery) changed = true;
    
    // Composite Yield
    const beforeComposite = String(rec[ headerToKey['Composite yield %'] ] || '');
    const afterComposite = computeCompositeYield(rec);
    if(beforeComposite !== afterComposite) changed = true;
    
    // Cost
    const beforeCost = String(rec[ headerToKey['Cost'] ] || '');
    const afterCost = computeCost(rec);
    if(beforeCost !== afterCost) changed = true;
  }
  if(changed) saveRows(rows);
}

/* render transposed */
function renderTransposed(){
  const area = document.getElementById('transposedArea');
  // Ensure Total Process Time is computed for all records before rendering
  computeTotalsForAllRecords();
  const data = window.__TRANS_DATA = loadData();
  area.innerHTML = "";

  // fields column
  const fieldsCol = document.createElement('div'); fieldsCol.className='fields-col';
  const toolbar = document.createElement('div'); toolbar.className='columns-toolbar'; toolbar.textContent='Fields';
  fieldsCol.appendChild(toolbar);
  // helper: convert 0=>A, 1=>B ... 25=>Z, 26=>AA etc.
  function indexToColLetter(i){
    let s = '';
    let n = i + 1; // 1-based
    while(n>0){
      const rem = (n-1) % 26;
      s = String.fromCharCode(65 + rem) + s;
      n = Math.floor((n-1)/26);
    }
    return s;
  }

  HEADERS.forEach((h, idx) => {
    const d = document.createElement('div'); d.className='field-label';
    const letter = indexToColLetter(idx);
    // create text node
    const txt = document.createElement('div'); txt.style.flex = '1'; txt.textContent = `${h} (${letter})`;
    d.appendChild(txt);

    // add info icons for calculated fields
    const lower = String(h||'').toLowerCase();

    // Total Process Time tooltip (detailed field names)
    if(lower.includes('total process time')){
      const icon = document.createElement('span'); icon.className = 'info-icon'; icon.textContent = 'ℹ';
      const tip = document.createElement('span'); tip.className = 'info-tooltip';
      tip.innerHTML = 'Total Process Time = Heating start time + Total reflux time + Total fraction cut collection time + <br>Total feeding time + Total Main collection time';
      icon.appendChild(tip); d.appendChild(icon);
    }

    // Total Heating Hours tooltip
    if(lower.includes('total heating hours')){
      const icon = document.createElement('span'); icon.className = 'info-icon'; icon.textContent = 'ℹ';
      const tip = document.createElement('span'); tip.className = 'info-tooltip';
      tip.innerHTML = 'Total heating hours = Heating stop time - Heating start time';
      icon.appendChild(tip); d.appendChild(icon);
    }

    // Main Recovery% tooltip
    if(lower.includes('main recovery')){
      const icon = document.createElement('span'); icon.className = 'info-icon'; icon.textContent = 'ℹ';
      const tip = document.createElement('span'); tip.className = 'info-tooltip';
      tip.textContent = 'Main Recovery% = (Output / Total Input) * 100';
      icon.appendChild(tip); d.appendChild(icon);
    }

    // Composite yield % tooltip
    if(lower.includes('composite yield')){
      const icon = document.createElement('span'); icon.className = 'info-icon'; icon.textContent = 'ℹ';
      const tip = document.createElement('span'); tip.className = 'info-tooltip';
      tip.innerHTML = 'Composite yield % = (F-1 + F-2 + Residue + Drain qty while sampling + Output + Water) <br>/ Total Input* 100';
      icon.appendChild(tip); d.appendChild(icon);
    }

    // Cost tooltip
    if(lower.includes('cost')){
      const icon = document.createElement('span'); icon.className = 'info-icon'; icon.textContent = 'ℹ';
      const tip = document.createElement('span'); tip.className = 'info-tooltip';
      tip.textContent = 'Cost = Total heating hours (hours) * 4000 / Total Input';
      icon.appendChild(tip); d.appendChild(icon);
    }

    fieldsCol.appendChild(d);
  });
  area.appendChild(fieldsCol);

  // columns
  data.forEach((rec, colIndex) => {
    const col = document.createElement('div'); col.className='record-col';
    // header with record label and remove (×) button
    const header = document.createElement('div'); header.className='record-header'; header.style.display='flex'; header.style.justifyContent='space-between'; header.style.alignItems='center';
    const label = document.createElement('div'); label.textContent = `Record ${colIndex+1}`; label.style.fontWeight='700';
    const removeBtn = document.createElement('button'); removeBtn.textContent = '×'; removeBtn.title = 'Remove record'; removeBtn.style.border='0'; removeBtn.style.background='transparent'; removeBtn.style.fontSize='18px'; removeBtn.style.cursor='pointer'; removeBtn.style.color='var(--slate)';
    removeBtn.onclick = ()=>{ deleteColumn(colIndex); };
    header.appendChild(label); header.appendChild(removeBtn); col.appendChild(header);
    const inner = document.createElement('div'); inner.className='record-col-inner';

    HEADERS.forEach(h => {
  const key = headerToKey[h];
  const cell = document.createElement('div'); cell.className='cell';
  const lower = h.toLowerCase();
  const isDuration = DURATION_FIELDS.some(df => lower.includes(df));
  const isHeatingStopDateTime = lower.includes('heating stop time');
  const isHeatingStartDateTime = lower.includes('heating start time');
  const isBatchStopTime = lower.includes('batch stop time') || lower.includes('batch stop');
  const isDate = lower.includes('date') && !isHeatingStopDateTime; // keep date fields, but heating stop is datetime-local
  // Treat generic time fields as time, but exclude heating start/stop which use combined datetime pickers
  const isTime = !isDuration && (/\btime\b/.test(lower) || lower.includes('start time') || lower.includes('stop time') || lower.includes('heating stop time'));
  const isCalculated = lower.includes('main recovery') || lower.includes('composite yield') || lower.includes('total process time') || lower.includes('total heating hours') || lower.includes('cost');


  // show inline label on small screens (we hide the left field-col via CSS)
  const isSmall = window.innerWidth <= 720;
  if(isSmall){
    const lab = document.createElement('div');
    lab.className = 'cell-label';
    
    // add field name text
    const labelText = document.createElement('span');
    labelText.textContent = h;
    lab.appendChild(labelText);
    
    // add info icon for calculated fields on mobile too
    if(lower.includes('total process time')){
      const icon = document.createElement('span'); icon.className = 'info-icon'; icon.textContent = 'ℹ';
      const tip = document.createElement('span'); tip.className = 'info-tooltip';
      tip.innerHTML = 'Total Process Time =<br>Heating start time + Total reflux time + Total fraction cut collection time + Total feeding time + Total Main collection time';
      icon.appendChild(tip); lab.appendChild(icon);
    } else if(lower.includes('total heating hours')){
      const icon = document.createElement('span'); icon.className = 'info-icon'; icon.textContent = 'ℹ';
      const tip = document.createElement('span'); tip.className = 'info-tooltip';
      tip.innerHTML = 'Total heating hours = Heating stop time - Heating start time (HH:MM)';
      icon.appendChild(tip); lab.appendChild(icon);
    } else if(lower.includes('main recovery')){
      const icon = document.createElement('span'); icon.className = 'info-icon'; icon.textContent = 'ℹ';
      const tip = document.createElement('span'); tip.className = 'info-tooltip';
      tip.textContent = 'Main Recovery% = (Output / Total Input) * 100';
      icon.appendChild(tip); lab.appendChild(icon);
    } else if(lower.includes('composite yield')){
      const icon = document.createElement('span'); icon.className = 'info-icon'; icon.textContent = 'ℹ';
      const tip = document.createElement('span'); tip.className = 'info-tooltip';
      tip.textContent = 'Composite yield % = (F-1 + F-2 + Residue + Drain qty while sampling + Output + Water) / Total Input';
      icon.appendChild(tip); lab.appendChild(icon);
    } else if(lower.includes('cost')){
      const icon = document.createElement('span'); icon.className = 'info-icon'; icon.textContent = 'ℹ';
      const tip = document.createElement('span'); tip.className = 'info-tooltip';
      tip.textContent = 'Cost = Total heating hours (hours) * 4000 / Total Input';
      icon.appendChild(tip); lab.appendChild(icon);
    }
    
    cell.appendChild(lab);
  }

  if (isCalculated){
    // Read-only display for calculated fields — styled to match input widths
    const display = document.createElement('div');
    display.className = 'calculated-display';
    display.style.padding = '10px 12px';
    display.style.border = '2px solid var(--border-light)';
    display.style.borderRadius = '8px';
    display.style.height = '44px';
    display.style.display = 'flex';
    display.style.alignItems = 'center';
    display.style.backgroundColor = '#f8fafc';
    display.style.color = 'var(--slate)';
    display.style.fontWeight = '500';
    display.style.width = '100%';
    display.style.maxWidth = '260px';
    display.style.boxSizing = 'border-box';
    display.style.overflow = 'hidden';
    display.style.textOverflow = 'ellipsis';
    display.style.whiteSpace = 'nowrap';
    display.textContent = rec[key] ?? '';
    cell.appendChild(display);

  } else if (isDate){
    const input = document.createElement('input'); input.type='date'; input.placeholder='YYYY-MM-DD';
    if (rec[key]) {
      const iso = parseToISODate(rec[key]);
      if (iso) input.value = iso;
    }
    // Add validation on blur/change
    input.onblur = () => {
      const val = String(input.value || '').trim();
      if(!val) input.classList.add('required-empty');
      else input.classList.remove('required-empty');
    };
    input.onchange = (e) => { const d = loadRowsRaw(); const v = String(e.target.value||'').trim(); if (/^\d{4}-\d{2}-\d{2}$/.test(v)) d[colIndex][key]=v; else d[colIndex][key]=''; saveRows(d); renderTransposed(); };
    cell.appendChild(input);

  } else if (isHeatingStopDateTime){
    // Heating stop: single display field (dd-mm-yyyy hh:mm:ss) with combined picker button
    const container = document.createElement('div');
    container.style.display = 'flex';
    container.style.gap = '4px';
    container.style.alignItems = 'center';
    container.style.width = '100%';
    
    const display = document.createElement('input');
    display.type = 'text';
    display.placeholder = 'dd-mm-yyyy hh:mm:ss';
    display.value = rec[key] ?? "";
    display.style.flex = '1';
    display.style.padding = '10px 12px';
    display.style.border = '2px solid var(--border)';
    display.style.borderRadius = '8px';
    display.style.fontSize = '0.95rem';
    display.style.backgroundColor = '#fff';
    display.style.color = 'var(--slate)';
    display.style.maxWidth = '260px';
    
    const pickerBtn = document.createElement('button');
    pickerBtn.textContent = '📅';
    pickerBtn.style.padding = '10px 12px';
    pickerBtn.style.border = '2px solid var(--border)';
    pickerBtn.style.borderRadius = '8px';
    pickerBtn.style.backgroundColor = '#fff';
    pickerBtn.style.cursor = 'pointer';
    pickerBtn.style.fontSize = '1rem';
    
    const updateValue = (val) => {
      const d = loadRowsRaw();
      d[colIndex][key] = val;
      saveRows(d);
      display.value = val;
    };
    
    display.onchange = (e) => { updateValue(e.target.value); renderTransposed(); };
    
    pickerBtn.onclick = () => {
      const modal = document.createElement('div');
      modal.style.position = 'fixed';
      modal.style.top = '50%';
      modal.style.left = '50%';
      modal.style.transform = 'translate(-50%, -50%)';
      modal.style.backgroundColor = '#fff';
      modal.style.border = '2px solid var(--border)';
      modal.style.borderRadius = '12px';
      modal.style.padding = '20px';
      modal.style.zIndex = '10000';
      modal.style.boxShadow = '0 10px 40px rgba(0,0,0,0.2)';
      modal.style.minWidth = '320px';
      
      const title = document.createElement('div');
      title.textContent = 'Select Date & Time (dd-mm-yyyy hh:mm:ss)';
      title.style.fontWeight = '700';
      title.style.marginBottom = '16px';
      modal.appendChild(title);
      
      // Parse current value
      const current = display.value || '';
      const [datePart, timePart] = current.split(' ');
      const [dd, mm, yyyy] = datePart ? datePart.split('-') : ['01', '01', '2025'];
      const [hh, min, ss] = timePart ? timePart.split(':') : ['00', '00', '00'];
      
      // Date inputs
      const dateLabel = document.createElement('div');
      dateLabel.textContent = 'Date (dd-mm-yyyy):';
      dateLabel.style.fontWeight = '600';
      dateLabel.style.marginBottom = '8px';
      dateLabel.style.fontSize = '0.9rem';
      modal.appendChild(dateLabel);
      
      const dateContainer = document.createElement('div');
      dateContainer.style.display = 'flex';
      dateContainer.style.gap = '8px';
      dateContainer.style.marginBottom = '16px';
      dateContainer.style.justifyContent = 'center';
      
      const dayInput = document.createElement('input');
      dayInput.type = 'number';
      dayInput.min = '1';
      dayInput.max = '31';
      dayInput.value = dd || '01';
      dayInput.style.width = '60px';
      dayInput.style.padding = '8px';
      dayInput.style.border = '2px solid var(--border)';
      dayInput.style.borderRadius = '8px';
      dayInput.style.textAlign = 'center';
      
      const monthInput = document.createElement('input');
      monthInput.type = 'number';
      monthInput.min = '1';
      monthInput.max = '12';
      monthInput.value = mm || '01';
      monthInput.style.width = '60px';
      monthInput.style.padding = '8px';
      monthInput.style.border = '2px solid var(--border)';
      monthInput.style.borderRadius = '8px';
      monthInput.style.textAlign = 'center';
      
      const yearInput = document.createElement('input');
      yearInput.type = 'number';
      yearInput.min = '1900';
      yearInput.max = '2100';
      yearInput.value = yyyy || '2025';
      yearInput.style.width = '80px';
      yearInput.style.padding = '8px';
      yearInput.style.border = '2px solid var(--border)';
      yearInput.style.borderRadius = '8px';
      yearInput.style.textAlign = 'center';
      
      dateContainer.appendChild(dayInput);
      const slash1 = document.createElement('span');
      slash1.textContent = '-';
      slash1.style.fontSize = '1.2rem';
      slash1.style.fontWeight = '700';
      dateContainer.appendChild(slash1);
      dateContainer.appendChild(monthInput);
      const slash2 = document.createElement('span');
      slash2.textContent = '-';
      slash2.style.fontSize = '1.2rem';
      slash2.style.fontWeight = '700';
      dateContainer.appendChild(slash2);
      dateContainer.appendChild(yearInput);
      modal.appendChild(dateContainer);
      
      // Time inputs
      const timeLabel = document.createElement('div');
      timeLabel.textContent = 'Time (hh:mm:ss):';
      timeLabel.style.fontWeight = '600';
      timeLabel.style.marginBottom = '8px';
      timeLabel.style.fontSize = '0.9rem';
      modal.appendChild(timeLabel);
      
      const timeContainer = document.createElement('div');
      timeContainer.style.display = 'flex';
      timeContainer.style.gap = '8px';
      timeContainer.style.marginBottom = '16px';
      timeContainer.style.justifyContent = 'center';
      
      const hourInput = document.createElement('input');
      hourInput.type = 'number';
      hourInput.min = '0';
      hourInput.max = '23';
      hourInput.value = String(parseInt(hh) || 0).padStart(2, '0');
      hourInput.style.width = '60px';
      hourInput.style.padding = '8px';
      hourInput.style.border = '2px solid var(--border)';
      hourInput.style.borderRadius = '8px';
      hourInput.style.textAlign = 'center';
      
      const minInput = document.createElement('input');
      minInput.type = 'number';
      minInput.min = '0';
      minInput.max = '59';
      minInput.value = String(parseInt(min) || 0).padStart(2, '0');
      minInput.style.width = '60px';
      minInput.style.padding = '8px';
      minInput.style.border = '2px solid var(--border)';
      minInput.style.borderRadius = '8px';
      minInput.style.textAlign = 'center';
      
      const secInput = document.createElement('input');
      secInput.type = 'number';
      secInput.min = '0';
      secInput.max = '59';
      secInput.value = String(parseInt(ss) || 0).padStart(2, '0');
      secInput.style.width = '60px';
      secInput.style.padding = '8px';
      secInput.style.border = '2px solid var(--border)';
      secInput.style.borderRadius = '8px';
      secInput.style.textAlign = 'center';
      
      timeContainer.appendChild(hourInput);
      const colon1 = document.createElement('span');
      colon1.textContent = ':';
      colon1.style.fontSize = '1.2rem';
      colon1.style.fontWeight = '700';
      timeContainer.appendChild(colon1);
      timeContainer.appendChild(minInput);
      const colon2 = document.createElement('span');
      colon2.textContent = ':';
      colon2.style.fontSize = '1.2rem';
      colon2.style.fontWeight = '700';
      timeContainer.appendChild(colon2);
      timeContainer.appendChild(secInput);
      modal.appendChild(timeContainer);
      
      // Buttons
      const buttonsContainer = document.createElement('div');
      buttonsContainer.style.display = 'flex';
      buttonsContainer.style.gap = '8px';
      buttonsContainer.style.justifyContent = 'center';
      
      const okBtn = document.createElement('button');
      okBtn.textContent = 'OK';
      okBtn.className = 'btn';
      okBtn.style.padding = '8px 16px';
      okBtn.onclick = () => {
        const d = String(parseInt(dayInput.value) || 1).padStart(2, '0');
        const m = String(parseInt(monthInput.value) || 1).padStart(2, '0');
        const y = yearInput.value;
        const h = String(parseInt(hourInput.value) || 0).padStart(2, '0');
        const min = String(parseInt(minInput.value) || 0).padStart(2, '0');
        const s = String(parseInt(secInput.value) || 0).padStart(2, '0');
        updateValue(`${d}-${m}-${y} ${h}:${min}:${s}`);
        document.body.removeChild(modal);
        document.body.removeChild(overlay);
      };
      
      const cancelBtn = document.createElement('button');
      cancelBtn.textContent = 'Cancel';
      cancelBtn.className = 'btn ghost';
      cancelBtn.style.padding = '8px 16px';
      cancelBtn.onclick = () => {
        document.body.removeChild(modal);
        document.body.removeChild(overlay);
      };
      
      buttonsContainer.appendChild(okBtn);
      buttonsContainer.appendChild(cancelBtn);
      modal.appendChild(buttonsContainer);
      
      const overlay = document.createElement('div');
      overlay.style.position = 'fixed';
      overlay.style.top = '0';
      overlay.style.left = '0';
      overlay.style.right = '0';
      overlay.style.bottom = '0';
      overlay.style.backgroundColor = 'rgba(0,0,0,0.3)';
      overlay.style.zIndex = '9999';
      overlay.onclick = () => {
        document.body.removeChild(modal);
        document.body.removeChild(overlay);
      };
      
      document.body.appendChild(overlay);
      document.body.appendChild(modal);
      dayInput.focus();
    };
    
    container.appendChild(display);
    container.appendChild(pickerBtn);
    cell.appendChild(container);

  } else if (isHeatingStartDateTime){
    // Heating start: same combined date+time picker as Heating stop
    const container2 = document.createElement('div');
    container2.style.display = 'flex';
    container2.style.gap = '4px';
    container2.style.alignItems = 'center';
    container2.style.width = '100%';
    
    const display2 = document.createElement('input');
    display2.type = 'text';
    display2.placeholder = 'dd-mm-yyyy hh:mm:ss';
    display2.value = rec[key] ?? "";
    display2.style.flex = '1';
    display2.style.padding = '10px 12px';
    display2.style.border = '2px solid var(--border)';
    display2.style.borderRadius = '8px';
    display2.style.fontSize = '0.95rem';
    display2.style.backgroundColor = '#fff';
    display2.style.color = 'var(--slate)';
    display2.style.maxWidth = '260px';
    
    const pickerBtn2 = document.createElement('button');
    pickerBtn2.textContent = '📅';
    pickerBtn2.style.padding = '10px 12px';
    pickerBtn2.style.border = '2px solid var(--border)';
    pickerBtn2.style.borderRadius = '8px';
    pickerBtn2.style.backgroundColor = '#fff';
    pickerBtn2.style.cursor = 'pointer';
    pickerBtn2.style.fontSize = '1rem';
    
    const updateValue2 = (val) => {
      const d = loadRowsRaw();
      d[colIndex][key] = val;
      saveRows(d);
      display2.value = val;
    };
    
    display2.onchange = (e) => { updateValue2(e.target.value); renderTransposed(); };
    
    pickerBtn2.onclick = () => {
      const modal = document.createElement('div');
      modal.style.position = 'fixed';
      modal.style.top = '50%';
      modal.style.left = '50%';
      modal.style.transform = 'translate(-50%, -50%)';
      modal.style.backgroundColor = '#fff';
      modal.style.border = '2px solid var(--border)';
      modal.style.borderRadius = '12px';
      modal.style.padding = '20px';
      modal.style.zIndex = '10000';
      modal.style.boxShadow = '0 10px 40px rgba(0,0,0,0.2)';
      modal.style.minWidth = '320px';
      
      const title = document.createElement('div');
      title.textContent = 'Select Date & Time (dd-mm-yyyy hh:mm:ss)';
      title.style.fontWeight = '700';
      title.style.marginBottom = '16px';
      modal.appendChild(title);
      
      // Parse current value
      const current = display2.value || '';
      const [datePart, timePart] = current.split(' ');
      const [dd, mm, yyyy] = datePart ? datePart.split('-') : ['01', '01', '2025'];
      const [hh, min, ss] = timePart ? timePart.split(':') : ['00', '00', '00'];
      
      // Date inputs
      const dateLabel = document.createElement('div');
      dateLabel.textContent = 'Date (dd-mm-yyyy):';
      dateLabel.style.fontWeight = '600';
      dateLabel.style.marginBottom = '8px';
      dateLabel.style.fontSize = '0.9rem';
      modal.appendChild(dateLabel);
      
      const dateContainer = document.createElement('div');
      dateContainer.style.display = 'flex';
      dateContainer.style.gap = '8px';
      dateContainer.style.marginBottom = '16px';
      dateContainer.style.justifyContent = 'center';
      
      const dayInput = document.createElement('input');
      dayInput.type = 'number';
      dayInput.min = '1';
      dayInput.max = '31';
      dayInput.value = dd || '01';
      dayInput.style.width = '60px';
      dayInput.style.padding = '8px';
      dayInput.style.border = '2px solid var(--border)';
      dayInput.style.borderRadius = '8px';
      dayInput.style.textAlign = 'center';
      
      const monthInput = document.createElement('input');
      monthInput.type = 'number';
      monthInput.min = '1';
      monthInput.max = '12';
      monthInput.value = mm || '01';
      monthInput.style.width = '60px';
      monthInput.style.padding = '8px';
      monthInput.style.border = '2px solid var(--border)';
      monthInput.style.borderRadius = '8px';
      monthInput.style.textAlign = 'center';
      
      const yearInput = document.createElement('input');
      yearInput.type = 'number';
      yearInput.min = '1900';
      yearInput.max = '2100';
      yearInput.value = yyyy || '2025';
      yearInput.style.width = '80px';
      yearInput.style.padding = '8px';
      yearInput.style.border = '2px solid var(--border)';
      yearInput.style.borderRadius = '8px';
      yearInput.style.textAlign = 'center';
      
      // Time inputs
      const timeLabel = document.createElement('div');
      timeLabel.textContent = 'Time (HH:MM:SS):';
      timeLabel.style.fontWeight = '600';
      timeLabel.style.marginBottom = '8px';
      timeLabel.style.fontSize = '0.9rem';
      modal.appendChild(timeLabel);
      
      const timeContainer = document.createElement('div');
      timeContainer.style.display = 'flex';
      timeContainer.style.gap = '8px';
      timeContainer.style.marginBottom = '16px';
      timeContainer.style.justifyContent = 'center';
      
      const hourInput = document.createElement('input');
      hourInput.type = 'number';
      hourInput.min = '0';
      hourInput.max = '23';
      hourInput.value = hh || '00';
      hourInput.style.width = '60px';
      hourInput.style.padding = '8px';
      hourInput.style.border = '2px solid var(--border)';
      hourInput.style.borderRadius = '8px';
      hourInput.style.textAlign = 'center';
      
      const minInput = document.createElement('input');
      minInput.type = 'number';
      minInput.min = '0';
      minInput.max = '59';
      minInput.value = min || '00';
      minInput.style.width = '60px';
      minInput.style.padding = '8px';
      minInput.style.border = '2px solid var(--border)';
      minInput.style.borderRadius = '8px';
      minInput.style.textAlign = 'center';
      
      const secInput = document.createElement('input');
      secInput.type = 'number';
      secInput.min = '0';
      secInput.max = '59';
      secInput.value = ss || '00';
      secInput.style.width = '60px';
      secInput.style.padding = '8px';
      secInput.style.border = '2px solid var(--border)';
      secInput.style.borderRadius = '8px';
      secInput.style.textAlign = 'center';
      
      dateContainer.appendChild(dayInput);
      dateContainer.appendChild(monthInput);
      dateContainer.appendChild(yearInput);
      modal.appendChild(dateContainer);
      
      timeContainer.appendChild(hourInput);
      const colon1 = document.createElement('span'); colon1.textContent = ':'; colon1.style.fontSize='1.2rem'; colon1.style.fontWeight='700';
      timeContainer.appendChild(colon1);
      timeContainer.appendChild(minInput);
      const colon2 = document.createElement('span'); colon2.textContent = ':'; colon2.style.fontSize='1.2rem'; colon2.style.fontWeight='700';
      timeContainer.appendChild(colon2);
      timeContainer.appendChild(secInput);
      modal.appendChild(timeContainer);
      
      const buttonsContainer = document.createElement('div');
      buttonsContainer.style.display = 'flex';
      buttonsContainer.style.gap = '8px';
      buttonsContainer.style.justifyContent = 'center';
      
      const okBtn = document.createElement('button'); okBtn.textContent = 'OK'; okBtn.style.padding='8px 12px'; okBtn.style.borderRadius='8px'; okBtn.style.cursor='pointer';
      const cancelBtn = document.createElement('button'); cancelBtn.textContent = 'Cancel'; cancelBtn.style.padding='8px 12px'; cancelBtn.style.borderRadius='8px'; cancelBtn.style.cursor='pointer';
      
      okBtn.onclick = () => {
        // Format selected values to dd-mm-yyyy hh:mm:ss
        const dval = String(Number(dayInput.value||0)).padStart(2,'0');
        const mval = String(Number(monthInput.value||0)).padStart(2,'0');
        const yval = String(Number(yearInput.value||0)).padStart(4,'0');
        const hval = String(Number(hourInput.value||0)).padStart(2,'0');
        const minv = String(Number(minInput.value||0)).padStart(2,'0');
        const sval = String(Number(secInput.value||0)).padStart(2,'0');
        const out = `${dval}-${mval}-${yval} ${hval}:${minv}:${sval}`;
        updateValue2(out);
        document.body.removeChild(modal);
        document.body.removeChild(overlay);
        renderTransposed();
      };
      cancelBtn.onclick = () => { document.body.removeChild(modal); document.body.removeChild(overlay); };
      
      buttonsContainer.appendChild(okBtn);
      buttonsContainer.appendChild(cancelBtn);
      modal.appendChild(buttonsContainer);
      
      const overlay = document.createElement('div');
      overlay.style.position = 'fixed';
      overlay.style.top = '0';
      overlay.style.left = '0';
      overlay.style.right = '0';
      overlay.style.bottom = '0';
      overlay.style.backgroundColor = 'rgba(0,0,0,0.3)';
      overlay.style.zIndex = '9999';
      overlay.onclick = () => { document.body.removeChild(modal); document.body.removeChild(overlay); };
      
      document.body.appendChild(overlay);
      document.body.appendChild(modal);
      dayInput.focus();
    };
    
    container2.appendChild(display2);
    container2.appendChild(pickerBtn2);
    cell.appendChild(container2);

  } else if (isDuration){
    // Duration input: strict HH:MM format validation
    // On load, input is empty (not prefilled with 00:00)
    const dur = parseDurationString(String(rec[key]||""));
    const storedVal = String(rec[key]||"").trim();
    const input = document.createElement('input');
    input.type = 'text';
    input.placeholder = 'HH:MM';
    // Empty on load; only show value if already stored
    input.value = storedVal ? ((dur.h || '00') + ':' + (dur.m || '00')) : '';
    input.style.width = '100%';
    input.style.padding = '10px 12px';
    input.style.border = '2px solid var(--border)';
    input.style.borderRadius = '8px';
    input.style.height = '44px';
    input.setAttribute('data-field-key', key);
    
    // Real-time input validation and formatting
    input.oninput = (e) => {
      const val = e.target.value;
      // Allow user to type freely, but validate format in real-time
      // Expected: HH:MM (5 chars total)
      if(val.length === 2 && !/^\d{2}$/.test(val)){
        // Invalid hours
        input.classList.add('invalid');
        return;
      }
      if(val.length === 3 && val[2] !== ':'){
        // After 2 digits, must have :
        input.classList.add('invalid');
        return;
      }
      if(val.length > 5){
        // Max 5 chars (HH:MM)
        e.target.value = val.slice(0, 5);
        return;
      }
      // Check if digits in correct positions
      if(val.length > 0 && !/^\d{0,2}:?\d{0,2}$/.test(val)){
        input.classList.add('invalid');
        return;
      }
      input.classList.remove('invalid');
    };
    
    input.onchange = (e) => {
      const raw = loadRowsRaw();
      const v = String(e.target.value||'').trim();
      
      // Empty input is allowed (will be blank)
      if(!v){
        raw[colIndex][key] = '';
        saveRows(raw);
        renderTransposed();
        return;
      }
      
      // Validate strict HH:MM format
      const match = v.match(/^(\d{1,2}):(\d{2})$/);
      if(!match){
        input.classList.add('invalid');
        toast('Error: ' + h + ' must be in HH:MM format (e.g., 02:30)');
        input.focus();
        setTimeout(() => input.classList.remove('invalid'), 1500);
        return;
      }
      
      const hh = Number(match[1]);
      const mm = Number(match[2]);
      
      // Validate ranges
      if(hh < 0 || hh > 999 || mm < 0 || mm > 59){
        input.classList.add('invalid');
        toast('Error: ' + h + ' - hours 0-999, minutes 0-59');
        input.focus();
        setTimeout(() => input.classList.remove('invalid'), 1500);
        return;
      }
      
      // Format and store
      const formatted = formatDuration(String(hh), String(mm));
      raw[colIndex][key] = formatted;
      input.classList.remove('invalid');
      
      // Recompute total process time and cost
      computeTotalProcessTimeForRecord(raw[colIndex]);
      computeCost(raw[colIndex]);
      saveRows(raw);
      renderTransposed();
    };
    
    cell.appendChild(input);


  } else if (isTime){
    // 24-hour time input with HH:MM:SS format and picker
    const timeContainer = document.createElement('div');
    timeContainer.style.display = 'flex';
    timeContainer.style.gap = '4px';
    timeContainer.style.alignItems = 'center';
    timeContainer.style.width = '100%';
    
    // Text display
    const timeDisplay = document.createElement('input');
    timeDisplay.type = 'text';
    timeDisplay.placeholder = 'HH:MM:SS';
    timeDisplay.value = rec[key] ?? "";
    timeDisplay.style.flex = '1';
    timeDisplay.style.padding = '10px 12px';
    timeDisplay.style.border = '2px solid var(--border)';
    timeDisplay.style.borderRadius = '8px';
    timeDisplay.style.fontSize = '0.95rem';
    timeDisplay.style.backgroundColor = '#fff';
    timeDisplay.style.color = 'var(--slate)';
    
    // Time picker button
    const pickerBtn = document.createElement('button');
    pickerBtn.textContent = '🕐';
    pickerBtn.style.padding = '10px 12px';
    pickerBtn.style.border = '2px solid var(--border)';
    pickerBtn.style.borderRadius = '8px';
    pickerBtn.style.backgroundColor = '#fff';
    pickerBtn.style.cursor = 'pointer';
    pickerBtn.style.fontSize = '1rem';
    
    // Update handler
    const updateValue = (val) => {
      const d = loadRowsRaw();
      d[colIndex][key] = val;
      saveRows(d);
      timeDisplay.value = val;
    };
    
    timeDisplay.onchange = (e) => { updateValue(e.target.value); renderTransposed(); };
    
    pickerBtn.onclick = () => {
      // Create time picker modal
      const modal = document.createElement('div');
      modal.style.position = 'fixed';
      modal.style.top = '50%';
      modal.style.left = '50%';
      modal.style.transform = 'translate(-50%, -50%)';
      modal.style.backgroundColor = '#fff';
      modal.style.border = '2px solid var(--border)';
      modal.style.borderRadius = '12px';
      modal.style.padding = '20px';
      modal.style.zIndex = '10000';
      modal.style.boxShadow = '0 10px 40px rgba(0,0,0,0.2)';
      modal.style.minWidth = '300px';
      
      const title = document.createElement('div');
      title.textContent = 'Select Time (24-hour format)';
      title.style.fontWeight = '700';
      title.style.marginBottom = '16px';
      modal.appendChild(title);
      
      const inputsContainer = document.createElement('div');
      inputsContainer.style.display = 'flex';
      inputsContainer.style.gap = '8px';
      inputsContainer.style.marginBottom = '16px';
      inputsContainer.style.justifyContent = 'center';
      
      // Parse current value
      const currentVal = timeDisplay.value || '00:00:00';
      const [hh, mm, ss] = currentVal.split(':').map(v => parseInt(v) || 0);
      
      // Hour input
      const hourInput = document.createElement('input');
      hourInput.type = 'number';
      hourInput.min = '0';
      hourInput.max = '23';
      hourInput.value = String(hh).padStart(2, '0');
      hourInput.style.width = '60px';
      hourInput.style.padding = '8px';
      hourInput.style.border = '2px solid var(--border)';
      hourInput.style.borderRadius = '8px';
      hourInput.style.textAlign = 'center';
      hourInput.style.fontSize = '1rem';
      
      // Minute input
      const minInput = document.createElement('input');
      minInput.type = 'number';
      minInput.min = '0';
      minInput.max = '59';
      minInput.value = String(mm).padStart(2, '0');
      minInput.style.width = '60px';
      minInput.style.padding = '8px';
      minInput.style.border = '2px solid var(--border)';
      minInput.style.borderRadius = '8px';
      minInput.style.textAlign = 'center';
      minInput.style.fontSize = '1rem';
      
      // Second input
      const secInput = document.createElement('input');
      secInput.type = 'number';
      secInput.min = '0';
      secInput.max = '59';
      secInput.value = String(ss).padStart(2, '0');
      secInput.style.width = '60px';
      secInput.style.padding = '8px';
      secInput.style.border = '2px solid var(--border)';
      secInput.style.borderRadius = '8px';
      secInput.style.textAlign = 'center';
      secInput.style.fontSize = '1rem';
      
      inputsContainer.appendChild(hourInput);
      const colon1 = document.createElement('span');
      colon1.textContent = ':';
      colon1.style.fontSize = '1.2rem';
      colon1.style.fontWeight = '700';
      inputsContainer.appendChild(colon1);
      inputsContainer.appendChild(minInput);
      const colon2 = document.createElement('span');
      colon2.textContent = ':';
      colon2.style.fontSize = '1.2rem';
      colon2.style.fontWeight = '700';
      inputsContainer.appendChild(colon2);
      inputsContainer.appendChild(secInput);
      
      modal.appendChild(inputsContainer);
      
      // Buttons
      const buttonsContainer = document.createElement('div');
      buttonsContainer.style.display = 'flex';
      buttonsContainer.style.gap = '8px';
      buttonsContainer.style.justifyContent = 'center';
      
      const okBtn = document.createElement('button');
      okBtn.textContent = 'OK';
      okBtn.className = 'btn';
      okBtn.style.padding = '8px 16px';
      okBtn.onclick = () => {
        const h = String(parseInt(hourInput.value) || 0).padStart(2, '0');
        const m = String(parseInt(minInput.value) || 0).padStart(2, '0');
        const s = String(parseInt(secInput.value) || 0).padStart(2, '0');
        const timeStr = `${h}:${m}:${s}`;
        updateValue(timeStr);
        document.body.removeChild(modal);
        document.body.removeChild(overlay);
        renderTransposed();
      };
      
      const cancelBtn = document.createElement('button');
      cancelBtn.textContent = 'Cancel';
      cancelBtn.className = 'btn ghost';
      cancelBtn.style.padding = '8px 16px';
      cancelBtn.onclick = () => {
        document.body.removeChild(modal);
        document.body.removeChild(overlay);
      };
      
      buttonsContainer.appendChild(okBtn);
      buttonsContainer.appendChild(cancelBtn);
      modal.appendChild(buttonsContainer);
      
      const overlay = document.createElement('div');
      overlay.style.position = 'fixed';
      overlay.style.top = '0';
      overlay.style.left = '0';
      overlay.style.right = '0';
      overlay.style.bottom = '0';
      overlay.style.backgroundColor = 'rgba(0,0,0,0.3)';
      overlay.style.zIndex = '9999';
      overlay.onclick = () => {
        document.body.removeChild(modal);
        document.body.removeChild(overlay);
      };
      
      document.body.appendChild(overlay);
      document.body.appendChild(modal);
      hourInput.focus();
    };
    
    timeContainer.appendChild(timeDisplay);
    timeContainer.appendChild(pickerBtn);
    cell.appendChild(timeContainer);

  } else {
    const numericHeads = ["total","qty","input","Output","water","f-1","f-2","residue","drain","cost","sr. no","main recovery","composite yield"];
    // treat Total Process Time as text (HH:MM) even though it contains 'total'
    const isNumeric = numericHeads.some(nh => lower.includes(nh)) && !lower.includes('process time');
    // Check if this field requires numeric-only validation
    const requiresNumericOnly = NUMERIC_ONLY_FIELDS.some(nf => lower.includes(nf));
    
    const input = document.createElement('input'); 
    input.type = isNumeric ? 'number' : 'text'; 
    input.value = rec[key] ?? "";
    
    input.onchange = (e) => { 
      const d = loadRowsRaw(); 
      let v = String(e.target.value || '').trim();
      
      // Validate numeric-only fields
      if(requiresNumericOnly && v !== ''){
        if(!/^-?\d+(\.\d+)?$/.test(v)){
          // Invalid: show error and clear
          input.classList.add('invalid');
          toast('Error: ' + h + ' must be numeric only');
          setTimeout(() => input.classList.remove('invalid'), 1500);
          return;
        }
      }
      
      if(input.type==='number'){ 
        const n=parseFloat(String(v).replace(/,/g,'')); 
        v = isNaN(n)?v:n; 
      } 
      d[colIndex][key]=v; 
      saveRows(d);
      
      // Trigger calculations if this field is used in formulas
      const isUsedInFormulas = 
        lower.includes('total input') || 
        lower.includes('output') || 
        lower.includes('water') || 
        lower.includes('f-1') || 
        lower.includes('f-2') || 
        lower.includes('residue') || 
        lower.includes('drain');
      if(isUsedInFormulas){
        computeMainRecoveryPercent(d[colIndex]);
        computeCompositeYield(d[colIndex]);
        saveRows(d);
      }
      
      renderTransposed(); 
    };
    cell.appendChild(input);
  }

      inner.appendChild(cell);
});

    // After the last field (Remark), add per-column action buttons: Save Field & Clear Fields
    // per-column action area removed
      // (per-column action buttons removed — global Save/Clear fields available at bottom)
    // actions are now global (single Save + Clear) — no per-column actions


    col.appendChild(inner);
    area.appendChild(col);
  });

  // ensure at least one column
  if(data.length===0){
    const p = document.createElement('div'); p.style.padding='16px'; p.textContent='No records. Click Add Record.'; area.appendChild(p);
  }
}

/* parse date dd-mm-yyyy or dd/mm/yyyy to yyyy-mm-dd */
function parseToISODate(v){
  if(!v) return "";
  v = String(v).trim();
  if(/^\d{4}-\d{2}-\d{2}$/.test(v)) return v;
  const m = v.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})$/);
  if(m){ const d = pad(Number(m[1])), mo = pad(Number(m[2])), y = m[3]; return `${y}-${mo}-${d}`; }
  return "";
}

/* Add column (always allowed) and focus first input in new column */
function addColumn(data){
  const rows = loadRowsRaw();
  // Create a proper full record, not a __simple record
  const newRecord = data || defaultRecord();
  rows.push(newRecord);
  saveRows(rows);
  renderTransposed();
  // after render, focus first non-hidden input of last column
  setTimeout(()=> {
    const cols = document.querySelectorAll('.record-col');
    if(cols.length){
      const last = cols[cols.length-1];
      // find first visible / usable input (skip type=hidden)
      const inputs = Array.from(last.querySelectorAll('input'));
      const firstInput = inputs.find(i => i.type !== 'hidden');
      if(firstInput){ firstInput.focus(); firstInput.scrollIntoView({behavior:'smooth', block:'center', inline:'nearest'}); }
    }
  }, 120);
}

/* delete/duplicate if needed (not hooked to UI buttons by default) */
function deleteColumn(idx){
  const rows = loadRowsRaw();
  rows.splice(idx,1);
  if(rows.length===0) rows.push(defaultRecord());
  saveRows(rows);
  renderTransposed();
}
function duplicateColumn(idx){
  const rows = loadRowsRaw();
  const copy = JSON.parse(JSON.stringify(rows[idx]||defaultRecord()));
  rows.splice(idx+1,0,copy);
  saveRows(rows);
  renderTransposed();
}

/* Import */
document.getElementById('importXlsx').addEventListener('change', async (ev) => {
  const f = ev.target.files[0];
  if(!f) return;
  try{
    const data = await f.arrayBuffer();
    const wb = XLSX.read(data,{type:'array'});
    const ws = wb.Sheets[wb.SheetNames[0]];
    const aoa = XLSX.utils.sheet_to_json(ws,{header:1, raw:false});
    if(!aoa||aoa.length===0) return alert('No data found');
    const incomingHeaders = aoa[0].map(h => String(h||"").trim());
    const newRecords = [];
    for(let r=1;r<aoa.length;r++){
      const row = aoa[r];
      const obj = defaultRecord();
      for(let c=0;c<incomingHeaders.length;c++){
        const h = incomingHeaders[c];
        const val = row[c]!==undefined?row[c]:"";
        let mappedKey = null;
        for(const hh of Object.keys(headerToKey)){ if(hh.toLowerCase() === String(h).toLowerCase()){ mappedKey = headerToKey[hh]; break; } }
        if(!mappedKey){
          const norm = String(h||"").toLowerCase().replace(/\s+/g,' ').replace(/[^\w\s]/g,'').trim();
          for(const hh of Object.keys(headerToKey)){ const n2 = hh.toLowerCase().replace(/\s+/g,' ').replace(/[^\w\s]/g,'').trim(); if(n2===norm){ mappedKey = headerToKey[hh]; break; } }
        }
        if(!mappedKey) mappedKey = String(h||"").toLowerCase().replace(/\s+/g,'_').replace(/[^\w_]/g,'');
        const lower = String(h||"").toLowerCase();
        // Normalize imported time-like values into canonical 24-hour HH:MM when possible
        if((/\btime\b/.test(lower) || lower.includes('start time') || lower.includes('stop time') || lower.includes('heating start time') || lower.includes('Heating stop time')) && typeof val === 'string'){
          const as24 = parseTime24(String(val).trim());
          obj[mappedKey] = as24 || val;
        } else if(/\bdate\b/.test(lower) && typeof val === 'string'){
          const iso = parseToISODate(val); obj[mappedKey]= iso||val;
        } else obj[mappedKey]=val;
      }
      newRecords.push(obj);
    }
    if(newRecords.length===0) return alert('No rows to import');
    saveRows(newRecords);
    renderTransposed();
    toast('Imported ' + newRecords.length + ' rows');
  } catch(err){ console.error(err); alert('Import failed (see console)'); } finally { ev.target.value=""; }
});

/* Export */
document.getElementById('exportBtn').addEventListener('click', async ()=> {
  // Export: prefer DB records (so Sr. No. present). Fallback to local records.
  let records = window.__DB_LOADED_RECORDS || null;
  if(!records){
    if(db){ try { records = await loadFromFirestore(); } catch(e){ console.warn(e); } }
  }
  if(!records || records.length===0){
    // fallback: export local data (no sr_no)
    const local = loadData();
    if(!local || local.length===0) return alert('No records to export');
    // export without sr_no
    const aoa = [HEADERS];
    local.forEach(rec => {
      const row = HEADERS.map(h => { const key = headerToKey[h] || (String(h).toLowerCase().replace(/\s+/g,'_').replace(/[^\w_]/g,'')); return rec[key] !== undefined ? rec[key] : ""; });
      aoa.push(row);
    });
    const ws = XLSX.utils.aoa_to_sheet(aoa);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, "Production");
    XLSX.writeFile(wb, `production-${new Date().toISOString().slice(0,10)}.xlsx`);
    return;
  }

  // include Sr. No. as first column
  const exportHeaders = ['Sr. No.', ...HEADERS];
  const aoa = [exportHeaders];
  records.forEach(rec => {
    const row = exportHeaders.map(h => { const key = headerToKey[h] || (String(h).toLowerCase().replace(/\s+/g,'_').replace(/[^\w_]/g,'')); return rec[key] !== undefined ? rec[key] : ""; });
    aoa.push(row);
  });
  const ws = XLSX.utils.aoa_to_sheet(aoa);
  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws, "Production");
  XLSX.writeFile(wb, `production-${new Date().toISOString().slice(0,10)}.xlsx`);
});

/* UI hooks */
document.getElementById('addColBtn').addEventListener('click', ()=> addColumn());
document.getElementById('clearAllFieldsBtn').addEventListener('click', ()=> { /* user requested immediate clear */ clearFields(); });
document.getElementById('saveBtn').addEventListener('click', async ()=> {
  console.log('===== SAVE BUTTON CLICKED =====');
  
  // Validate all records have all fields filled
  clearValidationIndicators();
  if(!validateAllRecordsComplete()){
    toast('⚠️ All fields are required. Please fill in all fields (shown in red).', 3000);
    return;
  }
  
  logFieldMappings(); // Debug: show all field mappings
  
  // Save ALL global behavior: use sanitized rows so legacy records are normalized
  const rows = loadData();
  console.log('Raw rows loaded:', rows.length);
  console.log('Raw rows:', rows);
  
  // DEBUG: Check each row
  rows.forEach((r, idx) => {
    console.log(`Row ${idx} keys:`, Object.keys(r));
    console.log(`Row ${idx} data:`, r);
  });

  // prepare payload (remove internal marker keys) - pass records directly
  const payload = rows.map(r => {
    const o = {};
    Object.keys(r||{}).forEach(k=>{ if(!String(k).startsWith('__')) o[k]=r[k]; });
    return o;
  });
  console.log('Payload prepared:', payload.length);
  console.log('Payload:', payload);

  if(!db){
    // fallback local: keep backup and clear inputs
    console.log('Firestore not available, saving locally');
    try{ const existing = JSON.parse(localStorage.getItem(LOCAL_SAVE_BACKUP_KEY) || '[]'); const updated = existing.concat(payload); localStorage.setItem(LOCAL_SAVE_BACKUP_KEY, JSON.stringify(updated)); }catch(e){ console.warn('backup save failed', e); }
    clearAllFields(); toast('Saved locally (Firestore not available) — fields cleared'); return;
  }

  console.log('Attempting Firestore save...');
  try{
    const res = await saveToFirestore(payload);
    console.log('Save response:', res);
    // normalized response could be {saved: n} or an array
    const savedCount = (res && res.saved) ? res.saved : (Array.isArray(res)?res.length:0);
    console.log('Saved count:', savedCount);
    if(savedCount>0){
      clearAllFields(); toast('Data saved successfully!');
      const s = document.getElementById('fbStatus'); if(s) s.textContent = 'DB: saved ' + savedCount + ' rows';
    } else {
      console.warn('saveToFirestore returned 0 saved records');
      toast('No rows were saved to DB');
    }
    // don't switch to DB table automatically; stay in editor with cleared fields
  }catch(err){
    console.error('Error during save:', err);
    console.error('Error code:', err.code);
    console.error('Error message:', err.message);
    const msg = String(err && (err.code || err.message || err)).toLowerCase();
    if(msg.includes('permission') || msg.includes('not authenticated') || msg.includes('auth')){
      try{ const existing = JSON.parse(localStorage.getItem(LOCAL_SAVE_BACKUP_KEY) || '[]'); const updated = existing.concat(payload); localStorage.setItem(LOCAL_SAVE_BACKUP_KEY, JSON.stringify(updated)); }catch(e){ console.warn('backup save failed', e); }
      clearAllFields(); toast('Permissions blocked DB — saved locally and fields cleared'); const s = document.getElementById('fbStatus'); if(s) s.textContent = 'DB: permission denied (saved locally)';
    } else {
      toast('Save to DB failed (see console)');
    }
  }
});

document.getElementById('loadBtn').addEventListener('click', async ()=> {
  try{
    await loadFromFirestore();
  }catch(e){
    console.error(e);
    const msg = String(e && (e.code || e.message || e)).toLowerCase();
    if(msg.includes('permission')|| msg.includes('not authenticated')|| msg.includes('auth')){
      toast('Permissions prevent DB load — showing local data');
      renderTransposed();
    } else {
      toast('Load failed (see console)');
    }
  }
});

/* toast */
function toast(msg, duration=1400){
  const el = document.createElement('div'); el.textContent = msg;
  el.style.position='fixed'; el.style.right='16px'; el.style.bottom='16px';
  el.style.background='var(--success)'; el.style.color='white'; el.style.padding='10px 14px';
  el.style.borderRadius='10px'; el.style.boxShadow='0 6px 18px rgba(0,0,0,0.12)'; el.style.zIndex='10000'; document.body.appendChild(el);
  setTimeout(()=> el.remove(), duration);
}

/* init */
if(!localStorage.getItem(STORAGE_KEY)){ saveRows([defaultRecord()]); }
renderTransposed();
</script>
</body>
</html>
